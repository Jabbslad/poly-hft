//! Prometheus metrics implementation

use metrics::{counter, describe_counter, describe_gauge, describe_histogram, gauge, histogram};
use metrics_exporter_prometheus::PrometheusBuilder;
use std::net::SocketAddr;
use std::time::Duration;

/// Initialize the Prometheus metrics exporter
pub fn init_metrics_server(port: u16) -> anyhow::Result<()> {
    let addr: SocketAddr = ([0, 0, 0, 0], port).into();

    PrometheusBuilder::new()
        .with_http_listener(addr)
        .install()
        .map_err(|e| anyhow::anyhow!("Failed to install metrics exporter: {}", e))?;

    // Register metric descriptions
    register_metrics();

    tracing::info!(port = port, "Prometheus metrics server started");

    Ok(())
}

/// Register all metric descriptions
fn register_metrics() {
    // Latency histograms
    describe_histogram!(
        "polyhft_price_feed_latency_ms",
        "Binance event time to bot receive time latency in milliseconds"
    );
    describe_histogram!(
        "polyhft_orderbook_update_latency_ms",
        "Polymarket orderbook update latency in milliseconds"
    );
    describe_histogram!(
        "polyhft_signal_generation_latency_ms",
        "Signal generation latency in milliseconds"
    );
    describe_histogram!(
        "polyhft_order_submission_latency_ms",
        "Order submission latency in milliseconds"
    );

    // Counters
    describe_counter!("polyhft_price_ticks_total", "Total price updates received");
    describe_counter!(
        "polyhft_orderbook_updates_total",
        "Total order book updates received"
    );
    describe_counter!(
        "polyhft_signals_total",
        "Total signals generated by side, reason, and action"
    );
    describe_counter!("polyhft_orders_total", "Total orders by side and status");
    describe_counter!("polyhft_fills_total", "Total executed fills by side");
    describe_counter!(
        "polyhft_ws_reconnects_total",
        "WebSocket reconnection count by feed"
    );
    describe_counter!("polyhft_errors_total", "Errors by component and type");

    // Gauges
    describe_gauge!("polyhft_equity_usd", "Current equity value in USD");
    describe_gauge!("polyhft_unrealized_pnl_usd", "Open position P&L in USD");
    describe_gauge!("polyhft_realized_pnl_usd", "Closed position P&L in USD");
    describe_gauge!("polyhft_open_positions", "Number of open positions");
    describe_gauge!("polyhft_total_exposure_usd", "Total capital at risk in USD");
    describe_gauge!(
        "polyhft_drawdown_pct",
        "Current drawdown from peak as percentage"
    );
    describe_gauge!("polyhft_daily_pnl_usd", "Today's P&L in USD");
    describe_gauge!("polyhft_current_volatility", "Estimated BTC volatility");
    describe_gauge!("polyhft_active_markets", "Number of tracked markets");
}

/// Latency metric types
#[derive(Debug, Clone, Copy)]
pub enum LatencyMetric {
    /// Binance feed latency
    PriceFeed,
    /// Polymarket order book latency
    OrderBook,
    /// Signal generation latency
    SignalGeneration,
    /// Order submission latency
    OrderSubmission,
}

impl LatencyMetric {
    fn metric_name(&self) -> &'static str {
        match self {
            LatencyMetric::PriceFeed => "polyhft_price_feed_latency_ms",
            LatencyMetric::OrderBook => "polyhft_orderbook_update_latency_ms",
            LatencyMetric::SignalGeneration => "polyhft_signal_generation_latency_ms",
            LatencyMetric::OrderSubmission => "polyhft_order_submission_latency_ms",
        }
    }
}

/// Gauge metric types
#[derive(Debug, Clone, Copy)]
pub enum GaugeMetric {
    /// Current equity
    Equity,
    /// Unrealized P&L
    UnrealizedPnl,
    /// Realized P&L
    RealizedPnl,
    /// Open position count
    OpenPositions,
    /// Total exposure
    TotalExposure,
    /// Current drawdown percentage
    DrawdownPct,
    /// Daily P&L
    DailyPnl,
    /// Current volatility estimate
    CurrentVolatility,
    /// Active market count
    ActiveMarkets,
}

impl GaugeMetric {
    fn metric_name(&self) -> &'static str {
        match self {
            GaugeMetric::Equity => "polyhft_equity_usd",
            GaugeMetric::UnrealizedPnl => "polyhft_unrealized_pnl_usd",
            GaugeMetric::RealizedPnl => "polyhft_realized_pnl_usd",
            GaugeMetric::OpenPositions => "polyhft_open_positions",
            GaugeMetric::TotalExposure => "polyhft_total_exposure_usd",
            GaugeMetric::DrawdownPct => "polyhft_drawdown_pct",
            GaugeMetric::DailyPnl => "polyhft_daily_pnl_usd",
            GaugeMetric::CurrentVolatility => "polyhft_current_volatility",
            GaugeMetric::ActiveMarkets => "polyhft_active_markets",
        }
    }
}

/// Counter metric types
#[derive(Debug, Clone, Copy)]
pub enum CounterMetric {
    /// Price ticks received
    PriceTicks,
    /// Orderbook updates received
    OrderbookUpdates,
    /// Signals generated
    Signals,
    /// Orders submitted
    Orders,
    /// Fills received
    Fills,
    /// WebSocket reconnects
    WsReconnects,
    /// Errors
    Errors,
}

impl CounterMetric {
    fn metric_name(&self) -> &'static str {
        match self {
            CounterMetric::PriceTicks => "polyhft_price_ticks_total",
            CounterMetric::OrderbookUpdates => "polyhft_orderbook_updates_total",
            CounterMetric::Signals => "polyhft_signals_total",
            CounterMetric::Orders => "polyhft_orders_total",
            CounterMetric::Fills => "polyhft_fills_total",
            CounterMetric::WsReconnects => "polyhft_ws_reconnects_total",
            CounterMetric::Errors => "polyhft_errors_total",
        }
    }
}

/// Record a latency measurement
pub fn record_latency(metric: LatencyMetric, duration: Duration) {
    let value_ms = duration.as_secs_f64() * 1000.0;
    histogram!(metric.metric_name()).record(value_ms);
}

/// Set a gauge value
pub fn set_gauge(metric: GaugeMetric, value: f64) {
    gauge!(metric.metric_name()).set(value);
}

/// Increment a counter with labels
pub fn increment_counter(metric: CounterMetric, labels: &[(&'static str, String)]) {
    let labels_vec: Vec<(&'static str, String)> = labels.to_vec();
    counter!(metric.metric_name(), &labels_vec).increment(1);
}

/// Increment a counter without labels
pub fn increment_counter_simple(metric: CounterMetric) {
    counter!(metric.metric_name()).increment(1);
}

/// Increment price ticks counter
pub fn record_price_tick() {
    counter!("polyhft_price_ticks_total").increment(1);
}

/// Increment orderbook updates counter
pub fn record_orderbook_update() {
    counter!("polyhft_orderbook_updates_total").increment(1);
}

/// Record a signal with labels
pub fn record_signal(side: &str, reason: &str, action: &str) {
    counter!(
        "polyhft_signals_total",
        "side" => side.to_string(),
        "reason" => reason.to_string(),
        "action" => action.to_string()
    )
    .increment(1);
}

/// Record an order with labels
pub fn record_order(side: &str, status: &str) {
    counter!(
        "polyhft_orders_total",
        "side" => side.to_string(),
        "status" => status.to_string()
    )
    .increment(1);
}

/// Record a fill
pub fn record_fill(side: &str) {
    counter!(
        "polyhft_fills_total",
        "side" => side.to_string()
    )
    .increment(1);
}

/// Record a WebSocket reconnection
pub fn record_ws_reconnect(feed: &str) {
    counter!(
        "polyhft_ws_reconnects_total",
        "feed" => feed.to_string()
    )
    .increment(1);
}

/// Record an error
pub fn record_error(component: &str, error_type: &str) {
    counter!(
        "polyhft_errors_total",
        "component" => component.to_string(),
        "type" => error_type.to_string()
    )
    .increment(1);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_latency_metric_names() {
        assert_eq!(
            LatencyMetric::PriceFeed.metric_name(),
            "polyhft_price_feed_latency_ms"
        );
        assert_eq!(
            LatencyMetric::OrderBook.metric_name(),
            "polyhft_orderbook_update_latency_ms"
        );
        assert_eq!(
            LatencyMetric::SignalGeneration.metric_name(),
            "polyhft_signal_generation_latency_ms"
        );
        assert_eq!(
            LatencyMetric::OrderSubmission.metric_name(),
            "polyhft_order_submission_latency_ms"
        );
    }

    #[test]
    fn test_gauge_metric_names() {
        assert_eq!(GaugeMetric::Equity.metric_name(), "polyhft_equity_usd");
        assert_eq!(
            GaugeMetric::OpenPositions.metric_name(),
            "polyhft_open_positions"
        );
        assert_eq!(
            GaugeMetric::DrawdownPct.metric_name(),
            "polyhft_drawdown_pct"
        );
        assert_eq!(
            GaugeMetric::UnrealizedPnl.metric_name(),
            "polyhft_unrealized_pnl_usd"
        );
        assert_eq!(
            GaugeMetric::RealizedPnl.metric_name(),
            "polyhft_realized_pnl_usd"
        );
        assert_eq!(
            GaugeMetric::TotalExposure.metric_name(),
            "polyhft_total_exposure_usd"
        );
        assert_eq!(GaugeMetric::DailyPnl.metric_name(), "polyhft_daily_pnl_usd");
        assert_eq!(
            GaugeMetric::CurrentVolatility.metric_name(),
            "polyhft_current_volatility"
        );
        assert_eq!(
            GaugeMetric::ActiveMarkets.metric_name(),
            "polyhft_active_markets"
        );
    }

    #[test]
    fn test_counter_metric_names() {
        assert_eq!(
            CounterMetric::PriceTicks.metric_name(),
            "polyhft_price_ticks_total"
        );
        assert_eq!(
            CounterMetric::Signals.metric_name(),
            "polyhft_signals_total"
        );
        assert_eq!(CounterMetric::Errors.metric_name(), "polyhft_errors_total");
        assert_eq!(
            CounterMetric::OrderbookUpdates.metric_name(),
            "polyhft_orderbook_updates_total"
        );
        assert_eq!(CounterMetric::Orders.metric_name(), "polyhft_orders_total");
        assert_eq!(CounterMetric::Fills.metric_name(), "polyhft_fills_total");
        assert_eq!(
            CounterMetric::WsReconnects.metric_name(),
            "polyhft_ws_reconnects_total"
        );
    }

    #[test]
    fn test_latency_metric_clone() {
        let metric = LatencyMetric::PriceFeed;
        let cloned = metric;
        assert_eq!(metric.metric_name(), cloned.metric_name());
    }

    #[test]
    fn test_gauge_metric_clone() {
        let metric = GaugeMetric::Equity;
        let cloned = metric;
        assert_eq!(metric.metric_name(), cloned.metric_name());
    }

    #[test]
    fn test_counter_metric_clone() {
        let metric = CounterMetric::PriceTicks;
        let cloned = metric;
        assert_eq!(metric.metric_name(), cloned.metric_name());
    }

    #[test]
    fn test_latency_metric_debug() {
        let metric = LatencyMetric::PriceFeed;
        let debug_str = format!("{:?}", metric);
        assert!(debug_str.contains("PriceFeed"));
    }

    #[test]
    fn test_gauge_metric_debug() {
        let metric = GaugeMetric::Equity;
        let debug_str = format!("{:?}", metric);
        assert!(debug_str.contains("Equity"));
    }

    #[test]
    fn test_counter_metric_debug() {
        let metric = CounterMetric::PriceTicks;
        let debug_str = format!("{:?}", metric);
        assert!(debug_str.contains("PriceTicks"));
    }

    // Note: The actual recording functions call the metrics crate which needs a recorder installed.
    // Testing them would require setting up a mock recorder.
    // However, we can test that the functions don't panic when called.

    #[test]
    fn test_record_latency_no_panic() {
        // This should not panic even without a recorder
        record_latency(LatencyMetric::PriceFeed, Duration::from_millis(50));
    }

    #[test]
    fn test_set_gauge_no_panic() {
        set_gauge(GaugeMetric::Equity, 1000.0);
    }

    #[test]
    fn test_increment_counter_simple_no_panic() {
        increment_counter_simple(CounterMetric::PriceTicks);
    }

    #[test]
    fn test_increment_counter_with_labels_no_panic() {
        increment_counter(CounterMetric::Errors, &[("component", "test".to_string())]);
    }

    #[test]
    fn test_record_price_tick_no_panic() {
        record_price_tick();
    }

    #[test]
    fn test_record_orderbook_update_no_panic() {
        record_orderbook_update();
    }

    #[test]
    fn test_record_signal_no_panic() {
        record_signal("yes", "spot_divergence", "trade");
    }

    #[test]
    fn test_record_order_no_panic() {
        record_order("yes", "submitted");
    }

    #[test]
    fn test_record_fill_no_panic() {
        record_fill("yes");
    }

    #[test]
    fn test_record_ws_reconnect_no_panic() {
        record_ws_reconnect("binance");
    }

    #[test]
    fn test_record_error_no_panic() {
        record_error("feed", "connection_failed");
    }
}
